### 类
Kotlin中使用class来申明类
```
class Invoice{

}
```
类声明由calss关键字，类名，类头（类型参数，主构造函数）以及由大括号包围的类体构成。类头和类体都是可选的，如果一个类没有类体，可以省略花括号。

### 主构造函数
```
class Person constructor(firstname: String){

}
```
如果主构造函数没有任何注解或者可见性修饰符，可以省略`constructor`关键字
```
class Person(firstname: String){
    
}
```

主构造函数不能包含任何代码，初始化代码可以放到init关键字为前缀的初始化块中。
```
class Customer(name: String) {
    init {
        logger.info("Customer initialized with value ${name}")
    }
}
```

### 幕后字段
kotlin中不能声明字段，但是kotlin中是有字段的，他有一个幕后字段的概念，每一个属性可以有一个幕后字段，也可以没有。如果属性至少一个访问器使用默认实现，或者自定义访问器通过 field 引用幕后字段。

### 拓展函数
申明一个拓展函数，需要使用一个接收者类型也就是被拓展的类型作为前缀。下面的代码为`Mutable<Int>`添加一个swap函数：
```
fun MutableList<Int>.swap(index1: Int, index2: Int) {
    val tmp = this[index1] // “this”对应该列表
    this[index1] = this[index2]
    this[index2] = tmp
}
```

>这里的this在拓展函数内部，指代接收者对象。

### 拓展是静态解析的
拓展并不是真正修改他们所拓展的类，通过定义一个拓展，你并没有在类中插入新成员，仅仅是通过该类型的变量用点表达式去调用这个函数。

拓展函数是静态分发的，即他们不是根据接收者类型的虚方法，这意味着调用的拓展函数是由函数调用所在的表达式的类型决定的，而不是由表达式运行时求值结果决定的。

如果一个类定义有一个成员函数和一个拓展函数，而这俩个函数又有相同的接收者类型，相同的名字并且都适用给定的参数，这种情况总是取成员函数。

### 可空接收者
注意为可空的接收者类型定义拓展，这样的拓展可以在对象变量上调用，即使其值为null,并且可以在函数体内检测`this == null`，这能让你在没有检测null的时候调用kotlin中的toString()方法：检测发生在拓展函数内部。

### 拓展属性
由于拓展函数没有实际的将成员插入类中，因此对拓展属性来说，幕后字段是无效的，因此**拓展属性不能有初始化器**

### 伴生对象的拓展
如果一个类定义有一个伴生对象，你也可以为伴生对象定义拓展函数和属性。

### 拓展的作用域
大多数时候在顶层定义拓展，即直接在包里：
```
package foo.bar

fun Bar.foo(){......}
```
要使用所定义包之外的一个拓展，需要在调用方引入。

### 拓展声明为成员
在一个类内部你可以为另一个类声明拓展，在这样的拓展内部，有多个隐式接收者--其中的对象成员可以无需通过限定符访问。拓展声明所在的类的实例称为`分发接收者`，拓展方法调用所在的接收者类型称为拓展接收者。

对于分发接收者和拓展接收者成员名称冲突的情况，**拓展接收者优先**。要引用分发接收者的成员，可以使用限定的this语法。

声明为成员的拓展可以声明为open并在子类覆盖。这以为者这些函数的分发对于分发接收者是动态的，但对于接收者类型是静态的。

### 可见性修饰符
Kotlin中的可见性修饰符有四种：public, internal, protected, private，如果没有显示指定修饰符，**默认可见性是public**

### 数据类
我们经常创建一些只保存数据的类。在kotlin中，这叫做`数据类`，并标记为data。
```
data class User(val name: String, val age: Int)
```
编译器自动从主构造函数中声明的所有属性中导出一下成员：
- equals()/hashCode();
- toString()[User(name=John, age=42)];
- componentN函数，按声明顺序对应于所有属性;
- copy函数;

为保证生成的代码一致性和有意义的行为，数据类必须满足一下要求：
- 主构造函数需要至少有一个参数；
- 主构造函数的所有参数需要标记为var/val;
- 数据类不能是抽象，开放，密封或者内部的;

为数据类生成的component函数使他们可以在解构声明中使用。

### 密封类 todo

### 泛型
与Java类似，Kotlin中的类也可以有类型参数。
```
class Box<T>(t: T){
    var value = t;
}
```

### 型变
Java类型系统中最棘手的是通配符类型。Kotlin中没有，相反它有俩个其他的东西:声明处型变与类型投影。
